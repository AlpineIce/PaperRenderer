#version 460
#extension GL_GOOGLE_include_directive : require
#include "Common.glsl"

layout (local_size_x = 128) in;

//----------UNIFORM INPUT DATA----------//

layout(std430, set = 0, binding = 0) uniform InputData
{
    vec4 camPos;
    mat4 projection;
    mat4 view;
    uint64_t materialDataPtr;
    uint64_t modelDataPtr;
    uint objectCount;
    uint frameIndex;
} inputData;

//----------PER RENDER PASS INSTANCE DATA (also the main input data)----------//

struct RenderPassInstance
{
    uint modelInstanceIndex;
    uint LODsMaterialDataOffset;
    bool isVisible;
    float padding;
};

layout(std430, set = 0, binding = 2) readonly buffer RenderPassInstances
{
    RenderPassInstance datas[];
} inputObjects;

//mesh groups
struct LODMaterialData
{
    uint meshGroupsOffset;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialData
{
    LODMaterialData materialDatas[]; //count grabbed from model and is assumed to be in order
};

struct MaterialMeshGroup
{
    uint64_t bufferAddress;
    uint bufferFrameOffsetsOffset;
    uint indirectDrawDatasOffset;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialMeshGroups
{
    MaterialMeshGroup datas[]; //count grabbed from model and is assumed to be in order
};

layout(std430, buffer_reference) readonly buffer LODMaterialMeshGroupBufferOffsets
{
    uint bufferOffsets[];
};

//mesh group data
struct IndirectDrawData
{
    uint drawCountsOffset;
    uint drawCommandsOffset;
    uint outputObjectsOffset;
    uint padding;
};

layout(std430, buffer_reference) readonly buffer IndirectDrawDatas
{
    IndirectDrawData datas[]; //count grabbed from model and is assumed to be in order
};

//----------OUTPUT DATA----------//

//draw counts
layout(std430, buffer_reference) buffer DrawCounts
{
    uint count;
};

//draw commands
struct DrawCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, buffer_reference) writeonly buffer DrawCommands
{
    DrawCommand commands[];
};

//output object matrices
struct OutputObject
{
    mat4 model;
    mat4 objectTransform;
};

layout(std430, buffer_reference) writeonly buffer OutputObjects
{
    OutputObject objects[];
};

//----------FUNCTIONS----------//

DrawCommand buildDrawCommand(ModelMeshData meshData, uint writeIndex)
{
    DrawCommand drawCommand;
    drawCommand.indexCount = meshData.indexCount;
    drawCommand.instanceCount = 1;
    drawCommand.firstIndex = meshData.iboOffset;
    drawCommand.vertexOffset = int(meshData.vboOffset);
    drawCommand.firstInstance = writeIndex;

    return drawCommand;
}

OutputObject buildOutputObject(mat4 modelMatrix)
{
    OutputObject outputObject;
    outputObject.model = modelMatrix;
    outputObject.objectTransform = inputData.projection * inputData.view * modelMatrix;

    return outputObject;
}

//----------ENTRY POINT----------//

void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if(gID >= inputData.objectCount)
    {
        return;
    }

    RenderPassInstance inputInstance = inputObjects.datas[gID];
    ModelInstance modelInstance = inputInstances.modelInstances[inputInstance.modelInstanceIndex]; //should be at index 0 with the offset derrived from inputInstance

    Model model = InputModel(inputData.modelDataPtr + modelInstance.modelDataOffset).model; //should be at index 0 with the offset derrived from modelInstance

    mat4 modelMatrix = getModelMatrix(modelInstance);

    if(isInBounds(modelInstance, model, modelMatrix, inputData.projection, inputData.view) && inputInstance.isVisible) //culling
    {   
        //get LOD
        uint lodLevel = min(getLODLevel(modelInstance, model, inputData.camPos), model.lodCount - 1);

        ModelLOD modelLOD = ModelLODs(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + model.lodsOffset)).LODs[lodLevel];
        LODMaterialData materialData = LODsMaterialData(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset)).materialDatas[lodLevel];

        //loop through LOD materials
        for(uint matIndex = 0; matIndex < modelLOD.materialCount; matIndex++)
        {
            ModelLODMeshGroup modelMeshGroup = ModelLODMeshGroups(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + modelLOD.meshGroupOffset)).groups[matIndex];
            MaterialMeshGroup materialMeshGroup = LODsMaterialMeshGroups(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset + materialData.meshGroupsOffset)).datas[matIndex];

            uint outputBufferOffset = LODMaterialMeshGroupBufferOffsets(inputData.materialDataPtr + uint64_t(materialMeshGroup.bufferFrameOffsetsOffset) + uint64_t(inputInstance.LODsMaterialDataOffset)).bufferOffsets[inputData.frameIndex];

            //loop through material meshes
            for(uint meshIndex = 0; meshIndex < modelMeshGroup.meshCount; meshIndex++)
            {
                ModelMeshData meshData = ModelLODMeshGroupMeshes(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + modelMeshGroup.meshesOffset)).meshesData[meshIndex];
                IndirectDrawData indirectDrawData = IndirectDrawDatas(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset + materialMeshGroup.indirectDrawDatasOffset)).datas[meshIndex];

                //draw counts and output objects
                DrawCounts drawCounts = DrawCounts(materialMeshGroup.bufferAddress + uint64_t(indirectDrawData.drawCountsOffset) + uint64_t(outputBufferOffset));
                DrawCommands outputCommands = DrawCommands(materialMeshGroup.bufferAddress + uint64_t(indirectDrawData.drawCommandsOffset) + uint64_t(outputBufferOffset));
                OutputObjects outputObjects = OutputObjects(materialMeshGroup.bufferAddress + uint64_t(indirectDrawData.outputObjectsOffset) + uint64_t(outputBufferOffset));

                uint writeIndex = atomicAdd(drawCounts.count, 1);

                //draw commands
                outputCommands.commands[writeIndex] = buildDrawCommand(meshData, writeIndex);

                //output objects
                outputObjects.objects[writeIndex] = buildOutputObject(modelMatrix);
            }
        }
    }
}