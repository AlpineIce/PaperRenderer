#version 460

#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require //for pointer arithmetic

layout (local_size_x = 128) in;

//----------UNIFORM INPUT DATA----------//

layout(std430, set = 0, binding = 0) uniform InputData //TODO CREATE CULLING FRUSTUM FROM PROJECTION
{
    vec4 camPos;
    mat4 projection;
    mat4 view;
    uint64_t materialDataPtr;
    uint64_t modelDataPtr;
    uint objectCount;
} inputData;

//----------MODEL INPUT DATA----------//

//model
struct AABB
{
    float posX;
    float negX;
    float posY;
    float negY;
    float posZ;
    float negZ;
};

struct Model
{
    AABB bounds;
    uint lodCount;
    uint lodsOffset;
};

layout(std430, buffer_reference) readonly buffer InputModel
{
    Model model;
};

//lods
struct ModelLOD
{
    uint materialCount;
    uint meshGroupOffset;
};

layout(std430, buffer_reference) readonly buffer ModelLODs
{
    ModelLOD LODs[];
};

//mesh group
struct ModelLODMeshGroup
{
    uint meshCount;
    uint meshesOffset;
};

layout(std430, buffer_reference) readonly buffer ModelLODMeshGroups
{
    ModelLODMeshGroup groups[];
};

//mesh
struct ModelMeshData
{
    uint vboOffset;
    uint vertexCount;
    uint iboOffset;
    uint indexCount;
};

layout(std430, buffer_reference) readonly buffer ModelLODMeshGroupMeshes
{
    ModelMeshData meshesData[];
};

//----------MODEL INSTANCE INPUT DATA----------//

//model instance
struct ModelInstance
{
    vec4 position; //w as padding
    vec4 scale;
    vec4 qRotation; //quaternion
    uint modelDataOffset;
    //defining a 12 byte padding here just breaks it
};

layout(std430, set = 0, binding = 1) readonly buffer InputInstances
{
    ModelInstance modelInstances[];
} inputInstances;

//----------PER RENDER PASS INSTANCE DATA (also the main input data)----------//

struct RenderPassInstance
{
    uint modelInstanceIndex;
    uint LODsMaterialDataOffset;
    bool isVisible;
    float padding;
};

layout(std430, set = 0, binding = 2) readonly buffer RenderPassInstances
{
    RenderPassInstance datas[];
} inputObjects;

//mesh groups
struct LODMaterialData
{
    uint meshGroupsOffset;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialData
{
    LODMaterialData materialDatas[]; //count grabbed from model and is assumed to be in order
};

struct MaterialMeshGroup
{
    uint indirectDrawDatasOffset;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialMeshGroups
{
    MaterialMeshGroup datas[]; //count grabbed from model and is assumed to be in order
};

//mesh group data
struct IndirectDrawData
{
    uint64_t bufferAddress;
    uint drawCountsOffset;
    uint drawCommandsOffset;
    uint outputObjectsOffset;
    uint padding;
};

layout(std430, buffer_reference) readonly buffer IndirectDrawDatas
{
    IndirectDrawData datas[]; //count grabbed from model and is assumed to be in order
};

//----------OUTPUT DATA----------//

//draw counts
layout(std430, buffer_reference) buffer DrawCounts
{
    uint count;
};

//draw commands
struct DrawCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, buffer_reference) writeonly buffer DrawCommands
{
    DrawCommand commands[];
};

//output object matrices
struct OutputObject
{
    mat4 model;
    mat4 objectTransform;
};

layout(std430, buffer_reference) writeonly buffer OutputObjects
{
    OutputObject objects[];
};

//----------DEBUG INFORMATION (THIS SHOULD NOT EXIST IF ANYONE BUT ME SEES IT)

struct DebugInfo
{
    uint matDataOffset;
};

layout(std430, set = 0, binding = 3) writeonly buffer DebugBuffer
{
    DebugInfo debugInfo[];
} debugBuffer;

//----------FUNCTIONS----------//

mat4 getModelMatrix(ModelInstance modelInstance)
{
    //from the GLM library
    mat4 result;

    //rotation
    vec4 q = modelInstance.qRotation;
    float qxx = q.x * q.x;
    float qyy = q.y * q.y;
    float qzz = q.z * q.z;
    float qxz = q.x * q.z;
    float qxy = q.x * q.y;
    float qyz = q.y * q.z;
    float qwx = q.w * q.x;
    float qwy = q.w * q.y;
    float qwz = q.w * q.z;

    result[0][0] = 1.0 - 2.0 * (qyy + qzz);
    result[0][1] = 2.0 * (qxy + qwz);
    result[0][2] = 2.0 * (qxz - qwy);

    result[1][0] = 2.0 * (qxy - qwz);
    result[1][1] = 1.0 - 2.0 * (qxx + qzz);
    result[1][2] = 2.0 * (qyz + qwx);

    result[2][0] = 2.0 * (qxz + qwy);
    result[2][1] = 2.0 * (qyz - qwx);
    result[2][2] = 1.0 - 2.0 * (qxx + qyy);

    result[3][3] = 1.0;

    //scale
    result[0][0] *= modelInstance.scale.x;
    result[1][1] *= modelInstance.scale.y;
    result[2][2] *= modelInstance.scale.z;

    //position
    result[3][0] = modelInstance.position.x;
    result[3][1] = modelInstance.position.y;
    result[3][2] = modelInstance.position.z;

    //other
    result[0][3] = 0.0;
    result[1][3] = 0.0;
    result[2][3] = 0.0;
    
    return result;
}

bool isInBounds(ModelInstance modelInstance, Model model, mat4 modelMatrix)
{
    AABB bounds = model.bounds;
                
    //construct 8 vertices
    vec3 vertices[8];
    vertices[0] = vec3(bounds.posX, bounds.posY, bounds.posZ);      // + + +
    vertices[1] = vec3(bounds.posX, bounds.posY, bounds.negZ);      // + + -
    vertices[2] = vec3(bounds.negX, bounds.posY, bounds.posZ);      // - + +
    vertices[3] = vec3(bounds.posX, bounds.negY, bounds.posZ);      // + - +
    vertices[4] = vec3(bounds.posX, bounds.negY, bounds.negZ);      // + - -
    vertices[5] = vec3(bounds.negX, bounds.posY, bounds.negZ);      // - + -
    vertices[6] = vec3(bounds.negX, bounds.negY, bounds.posZ);      // - - +
    vertices[7] = vec3(bounds.negX, bounds.negY, bounds.negZ);      // - - -

    //transform vertices and construct AABB
    AABB aabb;
    aabb.negX = 1000000.0f;
    aabb.negY = 1000000.0f;
    aabb.negZ = 1000000.0f;
    aabb.posX = -1000000.0f;
    aabb.posY = -1000000.0f;
    aabb.posZ = -1000000.0f;

    for(int i = 0; i < 8; i++)
    {
        vertices[i] = (inputData.view * modelMatrix * vec4(vertices[i], 1.0)).xyz;
        aabb.posX = max(vertices[i].x, aabb.posX);
        aabb.negX = min(vertices[i].x, aabb.negX);
        aabb.posY = max(vertices[i].y, aabb.posY);
        aabb.negY = min(vertices[i].y, aabb.negY);
        aabb.posZ = max(vertices[i].z, aabb.posZ);
        aabb.negZ = min(vertices[i].z, aabb.negZ);
    }

    //create culling frustum
    mat4 projectionT = transpose(inputData.projection);
    vec4 frustumX = (projectionT[3] + projectionT[0]) / length((projectionT[3] + projectionT[0]).xyz);
    vec4 frustumY = (projectionT[3] + projectionT[1]) / length((projectionT[3] + projectionT[1]).xyz);

    //visibility test
    bool visible = true;
    visible = visible && aabb.negZ < 0.0; //z test (cut everything behind)
    visible = visible && !((aabb.posX < ((frustumX.z / frustumX.x) * -aabb.negZ)) || //check left
                           (aabb.negX > ((frustumX.z / frustumX.x) * aabb.negZ))); //check right
    visible = visible && !((aabb.posY < (frustumY.y * aabb.negZ)) || //check top
                           (aabb.negY > (frustumY.y * -aabb.negZ))); //check bottom
    
	return visible;
}

uint getLODLevel(ModelInstance modelInstance, Model model)
{
    //get largest OBB extent to be used as size
    AABB bounds = model.bounds;
    float xLength = bounds.posX - bounds.negX;
    float yLength = bounds.posY - bounds.negY;
    float zLength = bounds.posZ - bounds.negZ;

    float worldSize = 0.0;
    worldSize = max(worldSize, xLength);
    worldSize = max(worldSize, yLength);
    worldSize = max(worldSize, zLength);

    float cameraDistance = length(modelInstance.position.xyz - inputData.camPos.xyz);
    
    uint lodLevel = uint(floor(inversesqrt(worldSize * 10.0) * sqrt(cameraDistance)));

    return lodLevel;
}

DrawCommand buildDrawCommand(ModelMeshData meshData, uint writeIndex)
{
    DrawCommand drawCommand;
    drawCommand.indexCount = meshData.indexCount;
    drawCommand.instanceCount = 1;
    drawCommand.firstIndex = meshData.iboOffset;
    drawCommand.vertexOffset = int(meshData.vboOffset);
    drawCommand.firstInstance = writeIndex;

    return drawCommand;
}

OutputObject buildOutputObject(mat4 modelMatrix)
{
    OutputObject outputObject;
    outputObject.model = modelMatrix;
    outputObject.objectTransform = inputData.projection * inputData.view * modelMatrix;

    return outputObject;
}

void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if(gID >= inputData.objectCount)
    {
        return;
    }

    RenderPassInstance inputInstance = inputObjects.datas[gID];
    ModelInstance modelInstance = inputInstances.modelInstances[inputInstance.modelInstanceIndex]; //should be at index 0 with the offset derrived from inputInstance
    Model model = InputModel(inputData.modelDataPtr + modelInstance.modelDataOffset).model; //should be at index 0 with the offset derrived from modelInstance

    mat4 modelMatrix = getModelMatrix(modelInstance);

    if(isInBounds(modelInstance, model, modelMatrix) && inputInstance.isVisible) //culling
    {   
        //get LOD
        uint lodLevel = min(getLODLevel(modelInstance, model), model.lodCount - 1);

        ModelLOD modelLOD = ModelLODs(inputData.modelDataPtr + modelInstance.modelDataOffset + model.lodsOffset).LODs[lodLevel];
        LODMaterialData materialData = LODsMaterialData(inputData.materialDataPtr + inputInstance.LODsMaterialDataOffset).materialDatas[lodLevel];

        debugBuffer.debugInfo[gID].matDataOffset = inputInstance.LODsMaterialDataOffset;

        //loop through LOD materials
        for(uint matIndex = 0; matIndex < modelLOD.materialCount; matIndex++)
        {
            ModelLODMeshGroup modelMeshGroup = ModelLODMeshGroups(inputData.modelDataPtr + modelInstance.modelDataOffset + modelLOD.meshGroupOffset).groups[matIndex];
            MaterialMeshGroup materialMeshGroup = LODsMaterialMeshGroups(inputData.materialDataPtr + inputInstance.LODsMaterialDataOffset + materialData.meshGroupsOffset).datas[matIndex];

            //loop through material meshes
            for(uint meshIndex = 0; meshIndex < modelMeshGroup.meshCount; meshIndex++)
            {
                ModelMeshData meshData = ModelLODMeshGroupMeshes(inputData.modelDataPtr + modelInstance.modelDataOffset + modelMeshGroup.meshesOffset).meshesData[meshIndex];
                IndirectDrawData indirectDrawData = IndirectDrawDatas(inputData.materialDataPtr + inputInstance.LODsMaterialDataOffset + materialMeshGroup.indirectDrawDatasOffset).datas[meshIndex];

                //draw counts and output objects
                DrawCounts drawCounts = DrawCounts(indirectDrawData.bufferAddress + indirectDrawData.drawCountsOffset);
                DrawCommands outputCommands = DrawCommands(indirectDrawData.bufferAddress + indirectDrawData.drawCommandsOffset);
                OutputObjects outputObjects = OutputObjects(indirectDrawData.bufferAddress + indirectDrawData.outputObjectsOffset);

                uint writeIndex = atomicAdd(drawCounts.count, 1);

                //draw commands
                outputCommands.commands[writeIndex] = buildDrawCommand(meshData, writeIndex);

                //output objects
                outputObjects.objects[writeIndex] = buildOutputObject(modelMatrix);
            }
        }
    }
}