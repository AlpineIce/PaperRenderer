#version 460

#extension GL_EXT_scalar_block_layout : require

//TODO gl_InstanceIndex instanced stuff

layout (local_size_x = 64) in;


//----------INPUT DATA----------//

layout(set = 0, binding = 0) buffer DrawCounts
{
    uint counts[];
} drawCounts;

struct InputObject
{
    mat4 matrix;
    vec4 position; //w component holds sphere extent
};

struct OutputObject
{
    mat4 model;
    mat4 objectTransform;
};

struct DrawCommand //24 bytes
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, set = 1, binding = 0) uniform InputData 
{
    mat4 projection;
    mat4 view;
    vec4 frustum; //(left, right, top, bottom)
    vec2 zPlanes; //(near, far)
    uint matrixCount;
    uint drawCountIndex;
    uint indexCount;
    uint padding;
} inputData;

layout(std430, set = 1, binding = 1) readonly buffer InputObjects
{
    InputObject objects[];
} inputObjects;

layout(std430, set = 1, binding = 2) buffer OutputObjects
{
    OutputObject objects[];
} outputObjects;

layout(std430, set = 1, binding = 3) buffer OutputCommands
{
    DrawCommand commands[];
} drawCommands;

//----------FUNCTIONS----------//

bool isInBounds(InputObject object)
{
    //grab sphere cull data from the object buffer
	vec4 sphereBounds = object.position;

	vec3 center = sphereBounds.xyz;
	center = (inputData.view * vec4(center,1.0)).xyz;
	float radius = 0.0;//sphereBounds.w;

	bool visible = true;

	//frustrum culling
	visible = visible && center.z * inputData.frustum.y - abs(center.x) * inputData.frustum.x > -radius;
	visible = visible && center.z * inputData.frustum.w - abs(center.y) * inputData.frustum.z > -radius;
    //visible = visible && center.z + radius > inputData.zPlanes.x && center.z - radius < inputData.zPlanes.y;

	return visible;
}

void main()
{
    uint gID = gl_GlobalInvocationID.x;

    if(gID >= inputData.matrixCount)
    {
        return;
    }
    else if(isInBounds(inputObjects.objects[gID]))
    {
        //add one into the draw count buffer at location of drawCountIndex, assign the pre-addition value into writeIndex, which will be the index into OutputObjects
        uint writeIndex = atomicAdd(drawCounts.counts[inputData.drawCountIndex], 1);

        //draw command data
        DrawCommand outputCommand;
        outputCommand.indexCount = inputData.indexCount;
        outputCommand.instanceCount = 1;
        outputCommand.firstIndex = 0;
        outputCommand.vertexOffset = 0;
        outputCommand.firstInstance = writeIndex;

        //output object data
        OutputObject outputObject;
        outputObject.model = inputObjects.objects[gID].matrix;
        outputObject.objectTransform = inputData.projection * inputData.view * inputObjects.objects[gID].matrix;

        //output
        drawCommands.commands[writeIndex] = outputCommand;
        outputObjects.objects[writeIndex] = outputObject;
    }
}