#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#include "../../../resources/shaders/Common.glsl"

layout (local_size_x = 256) in;

//----------UNIFORM INPUT DATA----------//

layout(push_constant, scalar) uniform InputData
{
    uint64_t inVboAddress;
    uint64_t outVboAddress;
    vec3 instancePosition;
    uint vertexCount;
    uint seed;
} inputData;

struct Vertex
{
    vec3 position;
    vec3 normal;
    vec2 uv;
};

layout(buffer_reference, scalar) buffer Vertices 
{
    Vertex v[];
};

//----------ENTRY POINT----------//

void main()
{
    const uint vertexIndex = gl_GlobalInvocationID.x;
    if(vertexIndex < inputData.vertexCount && inputData.inVboAddress != inputData.outVboAddress) // ANIMATE ALL LODS WHO CARES
    {
        // Read vertex from referenced geometry
        Vertex vertex = Vertices(inputData.inVboAddress).v[vertexIndex];

        // Z displacement
        const float xPhase = inputData.instancePosition.x + vertex.position.x * 8.0 + vertex.position.y * 5.0 + float(inputData.seed) / 5000.0;
        const float yPhase = inputData.instancePosition.x + vertex.position.x * -6.0 + vertex.position.y * 10.0 + float(inputData.seed) / 8000.0;
        const float displacement = sin(xPhase) + cos(yPhase);
        vertex.position.z += displacement * 0.03;

        // Fix normal (I really dont know if this works right, I mostly got it from chatgpt)
        const float dzdx = (cos(xPhase) * 8.0 - sin(yPhase) * -6.0) * 0.03;
        const float dzdy = (cos(xPhase) * 5.0 - sin(yPhase) * 10.0) * 0.03;
        vertex.normal = normalize(vertex.normal + vec3(-dzdx, -dzdy, 0.0));

        // Write to instance-specific geometry
        Vertices(inputData.outVboAddress).v[vertexIndex] = vertex;
    }
}