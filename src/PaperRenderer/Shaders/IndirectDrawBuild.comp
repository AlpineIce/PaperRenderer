#version 460
#extension GL_GOOGLE_include_directive : require
#include "Common.glsl"

layout (local_size_x = 128) in;

//----------UNIFORM INPUT DATA----------//

layout(std430, set = 0, binding = 0) uniform InputData
{
    vec4 camPos;
    mat4 projection;
    mat4 view;
    uint64_t materialDataPtr;
    uint64_t modelDataPtr;
    uint objectCount;
    bool doCulling;
} inputData;

//----------PER RENDER PASS INSTANCE DATA (also the main input data)----------//

struct RenderPassInstance
{
    uint modelInstanceIndex;
    uint LODsMaterialDataOffset;
    bool isVisible;
    float padding;
};

layout(std430, set = 0, binding = 2) readonly buffer RenderPassInstances
{
    RenderPassInstance datas[];
} inputObjects;

//mesh groups
struct LODMaterialData
{
    uint meshGroupsOffset;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialData
{
    LODMaterialData materialDatas[]; //count grabbed from model and is assumed to be in order
};

struct MaterialMeshGroup
{
    uint64_t bufferAddress;
    uint indirectDrawDatasOffset;
    uint padding;
};

layout(std430, buffer_reference) readonly buffer LODsMaterialMeshGroups
{
    MaterialMeshGroup datas[]; //count grabbed from model and is assumed to be in order
};

//mesh group data
struct IndirectDrawData
{
    uint drawCommandOffset;
    uint outputObjectsOffset;
};

layout(std430, buffer_reference) readonly buffer IndirectDrawDatas
{
    IndirectDrawData datas[]; //count grabbed from model and is assumed to be in order
};

//----------OUTPUT DATA----------//

//draw counts
layout(std430, buffer_reference) buffer DrawCounts
{
    uint count;
};

//draw commands
struct DrawCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, buffer_reference) buffer DrawCommands
{
    DrawCommand commands[];
};

//output model matrices

layout(std430, buffer_reference) writeonly buffer OutputObjects
{
    mat4 modelMatrices[];
};

//----------ENTRY POINT----------//

void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if(gID >= inputData.objectCount)
    {
        return;
    }

    RenderPassInstance inputInstance = inputObjects.datas[gID];
    ModelInstance modelInstance = inputInstances.modelInstances[inputInstance.modelInstanceIndex]; //should be at index 0 with the offset derrived from inputInstance

    Model model = InputModel(inputData.modelDataPtr + modelInstance.modelDataOffset).model; //should be at index 0 with the offset derrived from modelInstance

    mat4 modelMatrix = getModelMatrix(modelInstance);

    //culling
    bool visible = inputInstance.isVisible;
    if(inputData.doCulling && visible)
    {
        visible = isInBounds(modelInstance, model, modelMatrix, inputData.projection, inputData.view);
    }
    
    //indirect draw build if visible
    if(true)
    {
        //get LOD
        uint lodLevel = min(getLODLevel(modelInstance, model, inputData.camPos), model.lodCount - 1);

        ModelLOD modelLOD = ModelLODs(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + model.lodsOffset)).LODs[lodLevel];
        LODMaterialData materialData = LODsMaterialData(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset)).materialDatas[lodLevel];

        //loop through LOD materials
        for(uint matIndex = 0; matIndex < modelLOD.materialCount; matIndex++)
        {
            ModelLODMeshGroup modelMeshGroup = ModelLODMeshGroups(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + modelLOD.meshGroupOffset)).groups[matIndex];
            MaterialMeshGroup materialMeshGroup = LODsMaterialMeshGroups(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset + materialData.meshGroupsOffset)).datas[matIndex];

            //loop through material meshes
            for(uint meshIndex = 0; meshIndex < modelMeshGroup.meshCount; meshIndex++)
            {
                ModelMeshData meshData = ModelLODMeshGroupMeshes(inputData.modelDataPtr + uint64_t(modelInstance.modelDataOffset + modelMeshGroup.meshesOffset)).meshesData[meshIndex];
                IndirectDrawData indirectDrawData = IndirectDrawDatas(inputData.materialDataPtr + uint64_t(inputInstance.LODsMaterialDataOffset + materialMeshGroup.indirectDrawDatasOffset)).datas[meshIndex];

                //draw counts and output objects
                uint64_t inputMaterialPtr = inputData.materialDataPtr;
                uint64_t inputModelPtr = inputData.modelDataPtr;
                uint64_t commandAddress = materialMeshGroup.bufferAddress;
                uint64_t objectsAddress = materialMeshGroup.bufferAddress + uint64_t(indirectDrawData.outputObjectsOffset);
                DrawCommands outputCommands = DrawCommands(materialMeshGroup.bufferAddress);
                OutputObjects outputObjects = OutputObjects(materialMeshGroup.bufferAddress + uint64_t(indirectDrawData.outputObjectsOffset));

                uint writeIndex = atomicAdd(outputCommands.commands[indirectDrawData.drawCommandOffset].instanceCount, 1);

                //output objects
                outputObjects.modelMatrices[gID] = modelMatrix;
            }
        }
    }
}